# 第三章 **多线程服务器的适用场合与常用编程模型**

使用TCP长连接的好处有以下两点：
1.容易定位分布式系统中的服务之间的依赖关系。只要在机器上运行netstat -tpna | grep :port就能立刻列出用到某服务的客户端地址（Foreign列），然后在客户端的机器上用netstat或lsof命令找出是哪个进程发起的连接，这样在迁移服务器的时候能有效地防止出现outage（指服务中断或停机，特指服务器或服务无法正常运行，导致不可用的状态）。TCP短连接和UDP则不具备这一特性。

2.通过接收和发送队列的长度也较容易定位网络或程序故障。正常运行时，netstat打印的Recv-Q和Send-Q都应该接近0，或在0附近摆动。如果Recv-Q保持不变或持续增加，则通常意味着服务进程的处理速度变慢，可能发生了死锁或阻塞。如果Send-Q保持不变或持续增加，有可能是对方服务器太忙，来不及处理，也有可能是网络中间某个路由器或交换机故障造成丢包，甚至对方服务器掉线，这些因素都可能表现为数据发送不出去。通过持续监控Recv-Q和Send-Q就能及早预警性能或可用性故障。

线程的适用场景是：提高响应速度，让IO和计算相互重叠，降低latency。虽然多线程不能提高绝对性能，但能提高平均响应性能。

一个程序要做成多线程的，大致要满足：
1.有多个CPU可用。单核机器上多线程没有性能优势（但或许能简化并发业务逻辑的实现）。

2.线程间有共享数据，即内存中的全局状态。如果没有共享数据，用模型3b就行。虽然我们应该把线程间的共享数据降到最低，但不代表没有。

3.共享的数据是可以修改的，而不是静态的常量表。如果数据不能修改，那么可以在进程间用shared memory，模式3就能胜任。

4.提供非均质的服务。即，事件的响应有优先级差异，我们可以用专门的线程来处理优先级高的事件，防止优先级反转。

5.latency和throughput同样重要，不是逻辑简单的IO bound或CPU bound程序。换言之，程序要有相当的计算量（否则计算量小，单线程收到请求后直接就完成了，不需要交给其他线程去做）。

6.利用异步操作。如logging。无论往磁盘写log file，还是往log server发消息都不应阻塞critical path。

7.能scale up。一个好的多线程程序能享受增加CPU数目带来的好处，目前主流是8核，很快就会用到16核的机器了。

8.具有可预测的性能。随着负载增加，性能缓慢下降，超过某个临界点后会急速下降。线程数目一般不随负载变化。

9.多线程能有效地划分责任与功能，让每个线程的逻辑比较简单，任务单一，便于编码。而不是把所有逻辑都塞到一个event loop里，不同类别的事件之间相互影响。

